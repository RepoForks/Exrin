using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Framework
{
    /// <summary>
    /// This is myself going nuts on architectural frameworks to see what comes of it
    /// Most likely this will be completely over architected nonsense
    /// 
    /// Validation
    /// Error Handling
    /// Background threading so it doesn't lock the UI
    /// Visual Notification of progress
    /// App Insights or Logging
    /// Timeout callback
    /// Security
    /// Device Compatibility
    /// Completed
    /// 
    /// 
    /// 
    /// </summary>


    // TODO: Next I need to do one that all functions from a Model will call.
    // Validate, Security, Device Compatability

    public static class OperationService
    {
        private static Dictionary<object, bool> _status = new Dictionary<object, bool>();


        public class BaseViewModel
        {



        }

        internal class LoginViewModel : BaseViewModel
        {


        }

        internal class LoginModel
        {



        }


        public class BaseExecute : IViewModelExecute
        {
            public BaseExecute(IApplicationInsights insights)
            {
                Insights = insights;
            }

            public List<Operation> Operations { get; set; } = new List<Operation>();

            public virtual Task NotifyOfActivity() { return Task.FromResult(0); }

            public virtual Task NotifyActivityFinished() { return Task.FromResult(0); }

            public virtual Task<bool> HandleUnhandledException() { return Task.FromResult(false); }

            public virtual Task HandleTimeout() { return Task.FromResult(0); }

            public virtual Task Completed() { return Task.FromResult(0); }

            public IApplicationInsights Insights { get; private set; } = null;

            public int TimeoutMilliseconds { get; set; } = 0;

            public ExecutionResult ExecutionResult { get; set; } = new ExecutionResult();

        }



        // GOAL: Very unit testable
        // Enforce conventions throughout the app
        // Performance and reliability as key functions
        // Thread reliability



        // OUTPUT:
        // TESTABLE: // Navigation, DisplayAlert, Property{Binding} Change or Nothing
        // Notify Activities - dont need to be tested as they are base assigned


        // INPUT:
        // Operations and Rollback





        /// <summary>
        /// This is meant to be highly unit testable
        /// </summary>
        internal class LoginExecute : BaseExecute
        {
            private readonly LoginViewModel _viewModel = null;
            private readonly LoginModel _loginModel = null;

            public LoginExecute(LoginViewModel viewModel, LoginModel loginModel, IApplicationInsights insights) : base(insights)
            {
                _viewModel = viewModel;
                _loginModel = loginModel;

                Operations.Add(new Operation() { Function = Login, Rollback = LoginRollback });

            }

            // PURPOSE TO AT LEAST SEND A SIGNAL BACK TO SUCCESSFUL LOGIN OR NOT
            // THESE WILL BE PROPERTIES ON THE VIEWMODEL WITH BEHAVIORS
            // INTEGRATION TEST WITH PROPERTY SWITCH TEST. BUT CAN I? COULD CALL DIFFERENT FUNCTIONS?
            public Task Login()
            {
                // WARNING - HARD TO UNIT TEST DUE TO RESULT IN MODEL
                // INTEGRATION TEST
                //_loginModel.Authenticate();
                ExecutionResult.ResultAction = ResultType.Navigation;
                return Task.FromResult(0);
            }

            // TODO: Need to implement a navigation service that performs the stack switch
            // But doesn't rely on the Xamarin Forms Navigation Page.

            public Task LoginRollback()
            {
                return Task.FromResult(0);
            }


            public override Task Completed() // SHOULD I CHANGE THIS TO JUST A FUNCTION TO SWITCH NAVIGATION STACK / PAGE?
            {
                // WARNING - HARD TO UNIT TEST RESULT DUE TO EXTERNAL DEPENDENCY
                // Do Navigation Here
                //_viewModel.NavigationService

                return base.Completed();
            }
        }

     
// MUSTS

// Any MVVM Framework, Any DI Service

// This project must have 0 dependencies

// Allow rapid development, isolate, break and enhance as quick as possible.

// Disposal of resource to avoid memory leaks - a way to tag something to shut it down.


// IDEAS

// Remove Operation and Rollback (put them in the Model, not ViewModel) - ViewModel should be REALLY simple, just a relay. But it could need to rollback any state changes to the UI?

// Retry Helper Function with Policy

// Run on UI Thread helper - without XF dependency

// Model Execute

// Record Page State

// Enhance Page Cleanup (ViewModel to Page dispose at the same time)